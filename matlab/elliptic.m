function [X,Y,err]=elliptic(X,Y,tol,method)

% ELLIPTIC  Elliptic grid generation in two dimensions.
%
%    [Xe,Ye,err] = elliptic(X, Y, tol)
%
%    INPUT:
%      X, Y - matrices of dimension m*n containing initial
%             guess for coordinates of nodes in grid. They
%             can for example be generated by TRANSFINITE.
%      tol  - Absolute error tolerance. The Gauss-Seidel
%             iteration is interrupted when the arithmetic
%             average of the changes in node position is
%             smaller than the specified tolerance. Default
%             value = 1e-3.
%
%    OUTPUT:
%      Xe, Ye - matrices of dimension m*n containing coordinates
%               of grid points. The first and last columns and
%               rows contain the same elements as X and Y.
%      err    - the arithmetic average of the distance between
%               grid points between the last and second last
%               iterations.
%
%    See also TRANSFINITE and PLOTGRID.
%
%    [ 2D1263 Scientific Computing              ]
%    [ Christer Andersson (christe@nada.kth.se) ]
%    [ 12 January 2001                          ]


%------------------------------------------------------------
% Check input arguments

if (nargin < 3), tol=1e-3; end
if (tol < 0), error('Tolerance must be positive'); end
if (size(X) ~= size(Y)), error('X and Y must have same dimensions'); end

%------------------------------------------------------------
% Gauss-Seidel iteration
%   Matlab implementation of Code 1.1 in the lecture notes.
%   The nodes on the edges of the domain (the first and last
%   row and column) are kept fixed as specified in the input
%   matrices.
%
[ni,nj]=size(X);
err=2*tol;
if method==1
while (err > tol)
   err=0;
   for j=2:nj-1
      for i=2:ni-1
     g11=((X(i+1,j)-X(i-1,j))^2 + (Y(i+1,j)-Y(i-1,j))^2) / 4;
	 g22=((X(i,j+1)-X(i,j-1))^2 + (Y(i,j+1)-Y(i,j-1))^2) / 4;
	 g12=(X(i+1,j)-X(i-1,j)) * (X(i,j+1)-X(i,j-1))/4 + ...
             (Y(i+1,j)-Y(i-1,j)) * (Y(i,j+1)-Y(i,j-1))/4;
      x12=(X(i+1,j+1)-X(i+1,j-1)-X(i-1,j+1)+X(i-1,j-1))*0.5;   
      y12=(Y(i+1,j+1)-Y(i+1,j-1)-Y(i-1,j+1)+Y(i-1,j-1))*0.5; 
%      g12=0;
%          xtemp = 1/(2*(g11+g22))*(...
%            g22*X(i+1,j) - 0.5*g12*X(i+1,j+1) + 0.5*g12*X(i+1,j-1)+ ...
%            g11*X(i,j+1) + g11*X(i,j-1) + ...
%            g22*X(i-1,j) - 0.5*g12*X(i-1,j-1) + 0.5*g12*X(i-1,j+1) );
%          ytemp = 1/(2*(g11+g22))*(...
%            g22*Y(i+1,j) - 0.5*g12*Y(i+1,j+1) + 0.5*g12*Y(i+1,j-1)+ ...
%            g11*Y(i,j+1) + g11*Y(i,j-1) + ...
%            g22*Y(i-1,j) - 0.5*g12*Y(i-1,j-1) + 0.5*g12*Y(i-1,j+1) );
       
          xtemp = 1/(2*(g11+g22))*(g22*(X(i+1,j)+X(i-1,j))+g11*(X(i,j+1)+X(i,j-1))-g12*x12);
          ytemp = 1/(2*(g11+g22))*(g22*(Y(i+1,j)+Y(i-1,j))+g11*(Y(i,j+1)+Y(i,j-1))-g12*y12);

         err = err + (X(i,j)-xtemp)^2 + (Y(i,j)-ytemp)^2;
         X(i,j) = xtemp;
         Y(i,j) = ytemp;
      end
   end
   err = sqrt(err/((ni-2)*(nj-2)));
end
else                     %% SOR iteration method
    w=1.7;    
   while (err > tol)
   err=0;
   for j=2:nj-1
      for i=2:ni-1
     g11=((X(i+1,j)-X(i-1,j))^2 + (Y(i+1,j)-Y(i-1,j))^2)*0.25;
	 g22=((X(i,j+1)-X(i,j-1))^2 + (Y(i,j+1)-Y(i,j-1))^2)*0.25;
	 g12=(X(i+1,j)-X(i-1,j)) * (X(i,j+1)-X(i,j-1))*0.25 + ...
             (Y(i+1,j)-Y(i-1,j)) * (Y(i,j+1)-Y(i,j-1))*0.25;
      x12=(X(i+1,j+1)-X(i+1,j-1)-X(i-1,j+1)+X(i-1,j-1))*0.5;   
      y12=(Y(i+1,j+1)-Y(i+1,j-1)-Y(i-1,j+1)+Y(i-1,j-1))*0.5; 
%      g12=0;      
          xtemp = 1/(2*(g11+g22))*(g22*(X(i+1,j)+X(i-1,j))+g11*(X(i,j+1)+X(i,j-1))-g12*x12);
          ytemp = 1/(2*(g11+g22))*(g22*(Y(i+1,j)+Y(i-1,j))+g11*(Y(i,j+1)+Y(i,j-1))-g12*y12);

         err = err + (X(i,j)-xtemp)^2 + (Y(i,j)-ytemp)^2;
         %%X(i,j) = xtemp;
          X(i,j) =w*xtemp+(1-w)*X(i,j);
          Y(i,j) =w*ytemp+(1-w)*Y(i,j);
      end
   end
   err = sqrt(err/((ni-2)*(nj-2)));
    end
end
    